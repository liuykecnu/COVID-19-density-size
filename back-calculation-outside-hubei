 
Gam.star<-function(a, b, c, gam)
{  gv = 0
   if(gam[1]> 1/150 & gam[2]> 1e-3  & b>a & c>a)
   {
       coef = gamma(1/gam[1])/(gam[1]*gam[2])
       gv1 = pgamma( gam[2]*(c-a)^gam[1], 1/gam[1])
      
       gv2 = 0
       if(c>b){  gv2 =  pgamma( gam[2]*(c-b)^gam[1], 1/gam[1]) }
       gv = coef*(gv1-gv2)
   }
   gv
}

beta.fun<-function(alpha, wt){ alpha^2 / sum(alpha^2*wt) }

p.cal<-function(theta, time, time.c)
{
    k    = length(time)-1
    m    = length(time.c)-1   ####   length of beta

    alpha =  theta[1:m]
    beta  = beta.fun(alpha, diff(time.c) )

    gam =  theta[-c(1:m)]^2
    pp    =  rep(0, k) 
    for(j in 1:k){
       tmp = 1e-20
       for(i in 1:m)
       {  t1 = min(time[j+1], time.c[i+1])
          s1 = Gam.star(time.c[i], t1, time[j+1], gam)
          u1= t1 - time.c[i] - s1

          t2 = min(time[j], time.c[i+1])
          s2 = Gam.star(time.c[i], t2, time[j], gam) 
          u2 = t2- time.c[i] - s2 
           
          u3 = max(u1,0)  - (time[j]>time.c[i])*max(u2, 0)  
          tmp = tmp + max(u3, 0)*(time[j+1]>time.c[i])*beta[i] 
        }
       pp[j] = tmp      
    }
   pp
}

maxlike.N<-function(n, p0)
{
   obj<-function(n.big)
   {  if( p0<= 1e-4 ){ 
          out=sum( log((n.big-n+1):n.big)) + (n.big-n)*log(1e-4)
      }else{
          out = sum( log((n.big-n+1):n.big)) + (n.big-n)*log(p0)
       }
      -out
    }
  optimize(obj, c(n, 100*n))
}



maxlike <- function(x, time, time.c)
{  
   k = length(x)
   m = length(time.c) - 1   ###  length of beta
   n = sum(x)

   eps = 1e-8
   obj <-function(theta)
   {   p    = p.cal(theta, time, time.c)
       p0   = 1-sum(p)
       tmp = sum(x*log(eps))
       if( min(p)> eps ){ tmp =   sum(x*log(p)) }
       maxlike.N(n, p0)$objective  -  tmp 
    }

    theta0 =c(rep(1, m),1, 1) 
    theta = nlminb(theta0, obj, control=list(eval.max=500))$par
 
    alpha = theta[1:m]
    beta  = beta.fun(alpha, diff(time.c))
    gamma = theta[-(1:m)]^2

    pp = p.cal(theta, time, time.c)
    p0 = 1-sum(pp)
    n.big = round( maxlike.N(n, p0)$minimum )

    list(N.hat= n.big, Xproj=n.big-n, 
               gamma.hat=gamma, beta.hat=beta,  
               XvEx =cbind(x, round(n.big*pp)) )  
}


var.est.bootstrap <- function(N.hat, p.hat, time, time.c,  nboot=1000)
{   kk = length(p.hat)-1
    para = NULL
    for( i in 1:nboot)
    {   x.boot = rmultinom(1, N.hat,p.hat)
        out.boot=maxlike(x.boot[1:kk], time, time.c)
        tmp = c(out.boot$N.hat/N.hat, out.boot$gamma.hat, out.boot$beta.hat)
        cat('Bootrap No.', i,  tmp, '\n')
        para = rbind(para, tmp)
     }
    N.hat*var(para)
}



#############################################################################################
#############################################################################################
###############           Results   for outside Hubei      ################################## #############################################################################################
start.time = proc.time()

data=read.table('d:/coro-china.txt', head=T)
####   data[, 1]:   date
####   data[, 2]:   daily increase of confirmed cases in mainland China
####   data[, 3]:   daily increase of confirmed cases in Hubei 

x  = data[,2]-data[,3]    #  daily increase of confirmed cases outside Hubei 
add =  20                 #  There are 20 days between Jan 1  and Jan 20. 
step = 7


k   = length(x)
m   = round(k /step)   
time  = c(0,  add-1 + c(1:k))
time.c= c(0,  add,  add+ step*(1:(m-1)), max(time))

####  Here k is the length  of x;  time[2:(k+1)] must be the time points
####  at which  x records the number of newly confirmed cases. 
####  Therefore the length of ``time'' must be k+1. 

out = maxlike(x, time, time.c)
out

N.hat = out$N.hat
p.hat = c(out$XvEx[,1], out$Xproj)/N.hat
V.est =var.est.bootstrap(N.hat, p.hat, time, time.c, nboot=200)

end.time = proc.time()
end.time - start.time 
 
